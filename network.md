## OSI 7계층

7계층은 왜 나눌까?

통신이 일어나는 과정을 단계별로 알 수 있고, 특정한 곳에 이상이 생기면 그 단계만 수정할 수 있기 때문

1. 물리(Physical)
   * 리피터, 케이블, 허브 등
   * 단지 데이터를 전기적인 신호로 변환해서 주고 받는 기능을 진행하는 공간
   * 데이터를 전송하는 역할만 진행
2. 데이터 링크(Data Link)
   * 브릿지, 스위치 등
   * 물리 계층으로 송수신되는 정보를 관리하여 안전하게 전달되도록 도와주는 역할
   * Mac 주소를 통해 통신한다. 프레임에 Mac 주소를 부여하고 에러검출, 재전송, 흐름제어를 진행한다.
3. 네트워크(Network)
   * 라우터, IP
   * 데이터를 목적지까지 가장 안전하고 빠르게 전달하는 기능을 담당
   * 라우터를 통해 이동할 경로를 선택하여 IP 주소를 지정하고, 해당 경로에 따라 패킷을 전달해준다.
   * 라우팅, 흐름 제어, 오류 제어, 세그먼테이션 등을 수행한다.
4. 전송(Transport)
   * TCP, UDP
   * TCP와 UDP 프로토콜을 통해 통신을 활성화한다. 포트를 열어두고, 프로그램들이 전송할 수 있도록 제공해준다.
   * TCP : 신뢰성, 연결지향적
   * UDP : 비신뢰성, 비연결성, 실시간
5. 세션(Session)
   * API, Socket
   * 데이터가 통신하기 위한 논리적 연결을 담당한다.
   * TCP/IP 세션을 만들고 없애는 책임을 지니고 있다.
6. 표현(Presentation)
   * JPEG, MPEG 등
   * 데이터 표현에 대한 독립성을 제공하고 암호화하는 역할을 담당한다.
   * 파일 인코딩, 명령어를 포장, 압축, 암호화한다.
7. 응용(Application)
   * HTTP, FTP, DNS 등
   * 최종 목적지로, 응용 프로세스와 직접 관계하여 일반적인 응용 서비스를 수행한다.
   * 사용자 인터페이스, 전자우편, 데이터베이스 관리 등의 서비스를 제공한다.

----

## TCP  (Transmission Control Protocol)

* 네트워크 계층 중 전송 계층에서 사용하는 프로토콜
* 인터넷 상에서 데이터를 메세지의 형태(세그먼트라는 블록 단위)로 보내기 위해 IP와 함께 사용하는 프로토콜이다.
* TCP와 IP를 함께 사용하는데, IP가 데이터의 배달을 처리한다면 TCP는 패킷을 추적 및 관리한다.
* 연결형 서비스로 가상 회선 방식을 제공한다. (3 way handshaking, 4 way handshaking)
* 흐름제어 및 혼잡제어를 제공한다.
* 높은 신뢰성을 보장한다.
* UDP보다 속도가 느리다.
* 전이중(Full-Duplex), 점대점(Point to Point) 방식이다.
  * 전이중 : 전송이 양방향으로 동시에 일어날 수 있다.
  * 점대점 : 각 연결이 정확이 2개의 종단점을 가지고 있다.
* 연속성보다 신뢰성있는 전송이 중요할 때 사용된다.

### TCP 3 way handshake & 4 way handshake

###  3 way handshake - 연결 성립

TCP는 정확한 전송을 보장해야 한다. 따라서 통신하기에 앞서 논리적인 접속을 성립하기 위해 3 way handshake 과정을 진행한다.

1. 클라이언트가 서버에게 SYN 패킷을 보냄 (sequence : x)
2. 서버가 SYN을 받고, 클라이언트로 받았다는 신호인 ACK와 SYN 패킷을 보냄(sequence : y, ACK : x+1)
3. 클라이언트는 서버의 응답 ACK(x+1)와 SYN(y) 패킷을 받고, ACK(y+1) 를 서버로 보냄

### 4 way handshake - 연결 해제

연결 성립 후, 모든 통신이 끝났다면 해제해야 한다.

1. 클라이언트는 서버에게 연결을 종료한다는 FIN 플래그를 보낸다.
2. 서버는 FIN을 받고, 확인했다는 ACK를 클라이언트에게 보낸다. (이때 모든 데이터를 보내기 위해 TIME OUT 상태가 된다.)
3. 데이터를 보두 보냈다면, 연결이 종료되었다는 FIN 플래그를 클라이언트에게 보낸다.
4. 클라이언트는 FIN을 받고, 확인했다는 ACK를 서버에게 보낸다. (아직 서버로부터 받지 못한 데이터가 있을 수 있으므로 TIME_WAIT을 통해 기다린다.)

* 서버는 ACK를 받은 이후 소켓을 닫는다. (Closed)
* TIME_WAIT 시간이 끝나면 클라이언트도 닫는다. (Closed)

### 흐름제어/혼잡제어란?

* 흐름 제어 (Flow Control)
  * 데이터를 송신하는 곳과 수신하는 곳의 데이터 처리 속도를 조절하여 수신자의 버퍼 오버플로우를 방지하는 것
  * 송신하는 곳에서 감당할 수 없이 많은 데이터를 빠르게 보내  수신하는 곳에서 문제가 일어나는 것을 막는다.
* 혼잡 제어 (Congestion Control)
  * 네트워크 내의 패킷 수가 넘치게 증가하지 않도록 방지하는 것
  * 정보의 소통량이 과다하면 패킷을 조금만 전송하여 혼잡 붕괴 현상이 일어나는 것을 막는다.
  * 흐름제어가 송신측과 수신측 사이의 전송 속도를 다루는데 반해, 혼잡제어는 호스트와 라우터를 포함한 보다 넓은 관점에서 전송 문제를 다루게 된다.

---

## UDP (User Datagram Protocol)

* 네트워크 계층 중 전송 계층에서 사용하는 프로토콜
* 데이터를 데이터그램 단위로 처리하는 프로토콜이다.
* 비연결형 서비스로 데이터그램 방식을 제공한다.
  * 연결을 위해 할당되는 논리적인 경로가 없다.
  * 그렇기 때문에 각각의 패킷은 다른 경로로 전송되고, 각각의 패킷은 독립적인 관계를 지니게 된다.
  * 이렇게 데이터를 서로 다른 경로로 독립적으로 처리한다.

* 정보를 주고 받을 때 정보를 보내거나 받는다는 신호 절차를 거치지 않는다.
* UDP 헤더의 CheckSum 필드롤 통해 최소한의 오류만 검출한다.
* 신뢰성이 낮다.
* TCP보다 속도가 빠르다.
* 신뢰성보다는 연속성이 중요한 서비스, 예를 들면 실시간 서비스(streaming)에 사용된다.

---

## 대칭키 & 공개키

### 대칭키(Symmetric Key)

* 암호화와 복호화에 같은 암호키(대칭키)를 사용하는 알고리즘
* 동일한 키를 주고 받기 때문에 매우 빠르다는 장점이 있음
* 대칭키 전달 과정에서 해킹 위험에 노출

### 공개키(Public Key)

* 암호화와 복호화에 사용하는 암호키를 분리한 알고리즘
* 자신이 가지고 있는 고유한 암호키(비밀키)로만 복호화할 수 있는 암호키(공개키)를 대중에게 공개함
* 공개키 암호화 방식 진행 과정
  1. A가 웹 상에 공개된 B의 공개키를 이용해 평문을 암호화하여 B에게 보냄
  2. B는 자신의 비밀키로 복호화한 평문을 확인, A의 공개키로 응답을 암호화하여 A에게 보냄
  3. A는 자신의 비밀키로 암호화한 응답문을 복호화함
* 대칭키의 단점을 완벽하게 해결했지만, 암호화/복호화가 매우 복잡함

---

## HTTP & HTTPS

### HTTP (HyperText Transfer Protocol)

* 인터네 상에서 클라이언트와 서버가 저원을 주고 받을 때 쓰는 통신 규약
* HTTP는 텍스트 교환이므로 누군가 네트워크에서 신호를 가로채면 내용이 노출되는 보안 이슈가 존재한다.
* 이런 보안 문제를 해결해주는 프로토콜이 HTTPS

### HTTPS (HyperText Transfer Protocol Secure)

* 인터넷 상에서 정보를 암호화하는 SSL 프로토콜을 사용해 클라이언트와 서버가 자원을 주고 받을 때 쓰는 통신 규약
* HTTPS는 텍스트를 암호화한다. (공개키 암호화 방식으로)

---

## 로드밸런싱(Load Balancing)

로드 밸런싱은 분산식 웹 서비스로, 여러 서버에 부하(Load)를 나누어 주는 역할을 한다. Load Balancer를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 트래픽을 분산시켜주는 방식이다. 서비스를 운영하는 사이트의 규모에 따라 웹 서버를 추가로 증설하면서 로드 밸런서로 관리해주면 웹 서버의 부하를 해결할 수 있다.

---



---

http 요청과 응답

http 메세지

http 메서드

http 상태 코드

get post 차이

cors

소켓

---

참고 :

https://gyoogle.dev/blog/computer-science/network/OSI%207%EA%B3%84%EC%B8%B5.html

https://github.com/WeareSoft/tech-interview/blob/master/contents/network.md



